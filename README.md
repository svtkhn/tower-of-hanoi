# Tower of Hanoi

The Tower of Hanoi is a mathematical puzzle, for which the most efficient way to solve it for 3 poles has been found. However, finding the most efficient way for bigger number of rods is an open problem. A brute force program using Dr. Racket was written to find the solution by going through all possible steps. The program was improved by adding helper functions to avoid redundant steps (steps, which don’t reduce the number of steps to the solution) and the upper bound for the number of steps was determined for more than 3 poles. More improvements can lead to better upper bound by decreasing number of steps for solutions so the graph of the improved program fits or at least mostly concur with the ideal program graph. Therefore, the precise pattern can be seen and formulas for different number of poles can be determined.

This program can be served as an instrument in determening big-O of solutions for puzzles with more than 3 poles.More dateiled rules: https://en.wikipedia.org/wiki/Tower_of_Hanoi

IntroductionThe Tower of Hanoi is a mathematical puzzle, in which goal is to replace a pyramid of rings from one pole to another moving one disk at a time in the condition that bigger disk should never be put upon the smaller one. The most efficient way to solve it for 3 poles with arbitrary number of rings has been found (Hinz, 2013). The formula for the number of steps is 2n-1, where n is the number of rings. However, the finding of most efficient way for bigger number of poles is an open problem. In this research the problem was approached by writing an efficient program in Dr. Racket, which solves a problem with 3 or more poles, and determine the upper bound for steps required for each case.

MethodsInitially, the brute force version was written using DrRacket (see Appendix Brute Force Version for more information), where the program looks through all possible ring arrangements until it finds the solution (final arrangement, where the initial “pyramid” of rings is on the other pole). This version was treated as the least efficient one and the improvements were applied to decrease the number of steps by determining the length of visited accumulator and subtracting 1, because the initial arrangement is included in visited (see Appendix Brute force version funxtion “solve”).First main improvement (see Appendix Improvement #1) made the program to take the largest possible ring instead of going through all possible places of the first ring, then changing the second ring and going through all places of the first ring again. For example, in the case of 4 poles and 5 rings brute-force version would make first steps as it is shown on Figure 1. However, with this improvement the program would move the second ring as soon as possible (Figure 2). The reason under this improvement is that the purpose is to get to the solution by as few steps as possible. So, the improvement allows to skip the redundant steps by trying to move the largest ring as soon as possible. 